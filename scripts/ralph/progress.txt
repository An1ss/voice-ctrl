# Ralph Progress Log
Started: $(date +%Y-%m-%d)

## Codebase Patterns
(Patterns discovered during this feature build)

---

## US-001 - Set up project structure
**Implemented:**
- Initialized git repository
- Created Python virtual environment using `python3 -m venv venv`
- Set up directory structure: src/, config/, tests/, scripts/ralph/
- Created requirements.txt with 6 core dependencies
- Configured comprehensive .gitignore for Python projects
- Wrote detailed README.md with setup instructions

**Files changed:**
- .gitignore (created)
- requirements.txt (created)
- README.md (created)
- src/, config/, tests/, scripts/ralph/ directories (created)

**Learnings:**
- System uses python3 command (not python) on Ubuntu
- Python 3.12.3 is installed, well above 3.8+ requirement
- Virtual environment activation works via: source venv/bin/activate
- Git repository was not initialized yet - had to do git init first
- Used comprehensive .gitignore including IDE files and build artifacts
- README should include overview, features, requirements, setup, usage, and project structure

---

## US-002 - Record audio on keyboard shortcut
**Implemented:**
- Created src/recorder.py with AudioRecorder class for audio recording
- Created src/main.py as application entry point with global hotkey listener
- Created src/__init__.py to make src a proper Python package
- Implemented toggle recording behavior (press to start, press again to stop)
- Audio saved as WAV files in /tmp/ directory with timestamp filenames
- Used threading to avoid blocking keyboard listener during recording
- Configured 16kHz sample rate, mono channel for Whisper API compatibility
- Implemented 240-second maximum duration with automatic stop
- Added numpy dependency to requirements.txt

**Files changed:**
- src/recorder.py (created)
- src/main.py (created)
- src/__init__.py (created)
- requirements.txt (updated - added numpy)
- README.md (updated - added portaudio19-dev system dependency)

**Learnings:**
- sounddevice library requires system dependency: portaudio19-dev (must be installed via apt-get)
- pynput.keyboard.GlobalHotKeys is the correct class for cross-platform global hotkeys
- Audio data from sounddevice comes as float32 numpy arrays, must convert to int16 for WAV
- Threading is essential: recording runs in separate thread while keyboard listener remains responsive
- WAV files require specific format: setnchannels, setsampwidth(2 for 16-bit), setframerate
- /tmp/ directory is appropriate for temporary audio files (will be cleaned up by transcriber later)
- System dependency installation requires sudo, must be documented in README
- Audio conversion: multiply float32 by 32767 and cast to int16 for proper WAV encoding

---

## US-003 - Transcribe audio using OpenAI Whisper API
**Implemented:**
- Created src/transcriber.py with WhisperTranscriber class
- Integrated OpenAI Whisper API using the openai Python SDK (v2.15.0)
- Implemented config file reading from ~/.config/voice-ctrl/config.json with JSON parsing
- Configured API timeout to 30 seconds using OpenAI client timeout parameter
- Implemented comprehensive error handling with specific exception types
- Added automatic cleanup of temporary audio files using try/finally blocks
- Set up error logging to ~/.config/voice-ctrl/voice-ctrl.log with formatted timestamps
- Auto-create config directory (~/.config/voice-ctrl) if it doesn't exist using Path.mkdir()

**Files changed:**
- src/transcriber.py (created)

**Learnings:**
- OpenAI SDK v2.x uses client.audio.transcriptions.create() method (not Audio.transcribe())
- Must import specific exception classes: APIError, APIConnectionError, APITimeoutError, AuthenticationError, RateLimitError
- OpenAI client initialization: OpenAI(api_key=key, timeout=30.0) - timeout is a float in seconds
- Config file structure: Simple JSON with "openai_api_key" field
- File cleanup must be in finally block to ensure execution even when errors occur
- Python logging module needs basicConfig with filename, level, format, and datefmt parameters
- Path.mkdir(parents=True, exist_ok=True) creates all parent directories without errors if already exists
- API returns transcript object with .text attribute containing the transcribed string
- Whisper API accepts language parameter ("en" for English) though it can auto-detect
- Error logging format: [YYYY-MM-DD HH:MM:SS] LEVEL: message using %(asctime)s in format string
- Must open audio file in binary mode ('rb') when sending to API
- Path.unlink() deletes files, Path.exists() checks existence before deletion
- All errors should be caught, logged, and return None for graceful degradation

---

## US-004 - Insert transcribed text automatically
**Implemented:**
- Created src/paster.py with TextPaster class for clipboard-based text insertion
- Integrated TextPaster into main.py workflow (record → transcribe → paste)
- Implemented clipboard save and restore functionality with restore_clipboard parameter
- Added 100ms delay between clipboard copy and Ctrl+V to ensure clipboard readiness
- Comprehensive error handling for clipboard operations (empty text, None values, clipboard errors)
- Text pasting works via pyperclip + pynput keyboard simulation (Ctrl+V)

**Files changed:**
- src/paster.py (created)
- src/main.py (updated - added transcriber and paster integration)
- README.md (updated - added xclip system dependency)

**Learnings:**
- pyperclip requires system clipboard tool on Linux: xclip (X11), xsel, or wl-clipboard (Wayland)
- Must install xclip via apt-get: sudo apt-get install xclip
- pynput.keyboard.Controller simulates keystrokes at OS level, works across all applications
- Ctrl+V simulation: use with keyboard.pressed(Key.ctrl) context manager, then press/release 'v'
- Clipboard restore pattern: save with pyperclip.paste(), restore with pyperclip.copy() after delay
- 100ms delay (time.sleep(0.1)) between clipboard operations ensures reliability
- Edge cases handled: empty string, None, very long text all return appropriate success/failure status
- Paste returns boolean: True for success, False for failures (empty text, exceptions)
- Additional 100ms delay before restoring clipboard ensures paste operation completes
- Text truncation in logs ([:100]...) keeps console output readable for long transcriptions

---

## US-005 - Show system tray icon
**Implemented:**
- Created src/tray_icon.py with TrayIcon class for system tray management
- Implemented two icon states: idle (gray microphone) and recording (red microphone)
- Generated icons programmatically using PIL ImageDraw with simple microphone shapes
- Integrated tray icon into main.py with automatic state updates
- Icon runs in separate daemon thread to avoid blocking the main application
- Proper cleanup on application exit (stop icon when Ctrl+C pressed)
- Tooltip shows "Voice Control" on hover

**Files changed:**
- src/tray_icon.py (created)
- src/main.py (updated - added tray icon integration, fixed imports to use relative imports)

**Learnings:**
- pystray requires PIL (Pillow) for icon image creation
- Icon images created with Image.new('RGBA', (64, 64), (0, 0, 0, 0)) for transparent background
- PIL ImageDraw provides shapes: ellipse, rectangle, line, arc for drawing microphone icon
- pystray.Icon runs in blocking mode, must use threading.Thread(target=icon.run, daemon=True)
- Daemon thread ensures icon thread exits when main program exits
- Icon state changes via icon.icon = new_image_object (updates in real-time)
- main.py imports must be relative (.recorder, .transcriber, etc.) for proper module execution
- tray_icon.set_recording_state() called after recorder.toggle_recording() to sync icon state
- GNOME Shell on Ubuntu supports system tray icons (may need TopIcons extension on some systems)
- Test script confirmed: icon creation, start, state changes (idle↔recording), and stop all work correctly

---

## US-006 - Handle errors with notifications
**Implemented:**
- Created src/notifier.py with Notifier class for desktop notifications
- Integrated plyer library for cross-platform notifications (notify() function)
- Added specific notification methods for each error type:
  - notify_no_audio() - when no audio data recorded
  - notify_api_failure() - general API failures with optional details
  - notify_network_timeout() - 30-second timeout errors
  - notify_invalid_api_key() - authentication errors
  - notify_transcription_error() - general transcription errors
- Integrated notifier into transcriber.py to replace console error messages
- Integrated notifier into recorder.py to notify when no audio detected
- All errors logged to ~/.config/voice-ctrl/voice-ctrl.log with timestamp
- Notification timeout: 5 seconds for all error notifications
- Application continues running after non-fatal errors (returns None, doesn't crash)

**Files changed:**
- src/notifier.py (created)
- src/transcriber.py (updated - added notifier integration)
- src/recorder.py (updated - added notifier for no audio detection)
- test_notifier.py (created - test script)

**Learnings:**
- plyer.notification.notify() takes title, message, and timeout parameters
- plyer requires python3-dbus for best desktop integration on Linux, but has fallback
- Notifications work without sudo/special permissions on Ubuntu GNOME
- logging.basicConfig with force=True needed to override any existing logging config
- Notifier creates ~/.config/voice-ctrl/ directory automatically via Path.mkdir(parents=True, exist_ok=True)
- Each error type should have user-friendly messages (not technical details)
- Desktop notifications appear in system notification area for 5 seconds
- Log format: [YYYY-MM-DD HH:MM:SS] ERROR: Type: message
- notifier.notify_error() combines both desktop notification and file logging in one call
- Application continues running after errors since we return None instead of raising exceptions
- Test script confirms: all 5 error types show notifications and log correctly
- plyer fallback works even without dbus (uses notify-send command on Linux)

---

## US-007 - Use Shift+Insert for pasting instead of Ctrl+V
**Implemented:**
- Changed keyboard simulation from Ctrl+V to Shift+Insert in src/paster.py
- Modified TextPaster.paste_text() method to use Key.shift + Key.insert combination
- Updated all documentation strings and comments to reflect Shift+Insert usage
- Verified keystroke simulation works correctly with test script

**Files changed:**
- src/paster.py (updated - changed Ctrl+V to Shift+Insert in lines 9, 16, 54-58)

**Learnings:**
- Shift+Insert is the standard paste shortcut in Linux terminals and has better compatibility
- pynput Key class includes Key.insert constant for the Insert key
- Keyboard simulation pattern remains same: with keyboard.pressed(Key.shift): press/release Key.insert
- Shift+Insert works universally across terminal apps, terminal editors (vim, nano, emacs), and GUI apps
- Ctrl+V can be intercepted by terminals (e.g., vim uses it for visual block mode)
- Both shortcuts work in GUI apps, but Shift+Insert has superior terminal/CLI compatibility
- Test verified successful keystroke simulation output: "Simulated Shift+Insert keystroke"

---

## US-008 - Load settings from config file
**Implemented:**
- Created src/config.py with Config class for centralized settings management
- Implemented automatic default config creation at ~/.config/voice-ctrl/config.json on first run
- Added three configuration settings: api_key, max_duration_seconds, audio_feedback_enabled
- Implemented comprehensive config validation with type checking (string, number, boolean)
- Added error notifications for invalid config (JSON errors, type mismatches, missing file)
- Updated main.py to load Config and pass settings to components
- Refactored transcriber.py to use Config class instead of direct JSON reading
- Added backward compatibility for old 'openai_api_key' field (maps to 'api_key')
- Documented config file format and all options in README.md
- Tested all error scenarios: invalid JSON, invalid types, missing file

**Files changed:**
- src/config.py (created - 186 lines)
- src/main.py (updated - added Config import and initialization)
- src/transcriber.py (updated - removed _load_api_key method, now uses Config class)
- README.md (updated - added detailed config documentation with all options)

**Learnings:**
- Config management should be centralized in one module for consistency
- Always create default config on first run for better UX (user doesn't need to create manually)
- Config validation should check both structure and types (isinstance checks)
- Error notifications should be user-friendly, not technical (e.g., "Invalid config" not "JSONDecodeError")
- Use logging.basicConfig with force=True to override existing logging config across modules
- Backward compatibility is important: handle old field names (openai_api_key -> api_key)
- Settings should be applied at startup: pass config values to component constructors
- Config class methods should be semantic: get_api_key(), get_max_duration(), is_audio_feedback_enabled()
- Test invalid scenarios: malformed JSON, wrong types, missing files, negative numbers
- When refactoring, remove old code (deleted _load_api_key method) to avoid confusion
- Config should use .copy() on DEFAULT_CONFIG to prevent mutation
- Merge strategy: copy defaults first, then update with loaded values (ensures all keys exist)

---

## US-009 - Add audio feedback (beeps)
**Implemented:**
- Created src/audio_feedback.py with AudioFeedback class for playing beep sounds
- Implemented two distinct beeps: start (800 Hz, 0.1s) and stop (400 Hz, 0.15s)
- Integrated audio feedback into AudioRecorder class with audio_feedback_enabled parameter
- Updated main.py to pass audio_feedback_enabled config setting to recorder
- Beeps play asynchronously in daemon threads to avoid blocking recording
- Volume set to 0.3 (30%) for non-intrusive feedback
- Audio feedback can be toggled via set_enabled() method
- Respects audio_feedback_enabled config setting (defaults to True)

**Files changed:**
- src/audio_feedback.py (created - 87 lines)
- src/recorder.py (updated - added AudioFeedback import and integration)
- src/main.py (updated - pass audio_feedback_enabled from config)

**Learnings:**
- sounddevice library used for both recording and playback (no additional dependencies)
- Use numpy to generate sine wave beeps: np.sin(frequency * 2 * np.pi * t)
- Apply fade in/out envelope to prevent audio clicks at start/end of beep
- Fade duration: 10ms (0.01s) is sufficient to eliminate clicks
- Different frequencies convey different meanings: high (800 Hz) = start, low (400 Hz) = stop
- sd.play() is non-blocking by default - perfect for beeps
- Play beeps in daemon threads to ensure they don't prevent app shutdown
- Volume level 0.3 (30%) is loud enough to hear but not jarring
- Fail silently on audio playback errors (beeps are non-critical feature)
- Start beep plays BEFORE recording thread starts for immediate feedback
- Stop beep plays AFTER recording thread finishes to ensure audio doesn't interfere with recording
- AudioFeedback class is reusable and easily testable in isolation
- Integration test verified beeps play correctly and respect enabled/disabled state

---

## US-010 - Make keyboard shortcut configurable
**Implemented:**
- Added keyboard_shortcut setting to DEFAULT_CONFIG in config.py with default "Ctrl+Shift+Space"
- Implemented parse_keyboard_shortcut() function in main.py to parse user-friendly shortcut strings
- Supports common modifiers (Ctrl, Alt, Shift, Cmd) and special keys (Space, F1-F12, Insert, etc.)
- Parser converts user format ("Ctrl+Shift+Space") to pynput format ("<ctrl>+<shift>+<space>")
- Added comprehensive validation with helpful error messages showing valid format examples
- Shows desktop notification and exits gracefully if shortcut format is invalid
- Catches registration errors from pynput (e.g., invalid key combinations) with error notification
- Updated README with keyboard_shortcut documentation and usage notes

**Files changed:**
- src/config.py (updated - added keyboard_shortcut to DEFAULT_CONFIG, validation, and getter method)
- src/main.py (updated - added parse_keyboard_shortcut() function and error handling in main())
- README.md (updated - documented keyboard_shortcut setting with examples and restart requirement)

**Learnings:**
- pynput GlobalHotKeys requires format like "<ctrl>+<shift>+<space>" with angle brackets for special keys
- Parser must handle case-insensitive input ("Ctrl" vs "ctrl") and whitespace around + separator
- Single-character keys (a-z, 0-9) don't need angle brackets in pynput format
- Invalid shortcuts should fail early at startup with clear error messages, not silently
- Error messages should provide concrete examples of valid formats for better UX
- Shortcut validation has two stages: format parsing (our code) and registration (pynput library)
- Must catch exceptions from pynput.keyboard.GlobalHotKeys during registration (e.g., invalid combinations)
- Desktop notifications for config errors help users who run the app from autostart/systemd
- Config changes require app restart since pynput doesn't support dynamic hotkey re-registration
- Documenting the restart requirement is important for user expectations
- Parser supports function keys F1-F12 by generating key_map entries programmatically
- Using sys.exit(1) after configuration errors prevents app from running in broken state
- Map-based parsing approach is extensible for adding more special keys in future

---
