# Ralph Progress Log
Started: $(date +%Y-%m-%d)

## Codebase Patterns
(Patterns discovered during this feature build)

---

## US-001 - Set up project structure
**Implemented:**
- Initialized git repository
- Created Python virtual environment using `python3 -m venv venv`
- Set up directory structure: src/, config/, tests/, scripts/ralph/
- Created requirements.txt with 6 core dependencies
- Configured comprehensive .gitignore for Python projects
- Wrote detailed README.md with setup instructions

**Files changed:**
- .gitignore (created)
- requirements.txt (created)
- README.md (created)
- src/, config/, tests/, scripts/ralph/ directories (created)

**Learnings:**
- System uses python3 command (not python) on Ubuntu
- Python 3.12.3 is installed, well above 3.8+ requirement
- Virtual environment activation works via: source venv/bin/activate
- Git repository was not initialized yet - had to do git init first
- Used comprehensive .gitignore including IDE files and build artifacts
- README should include overview, features, requirements, setup, usage, and project structure

---

## US-002 - Record audio on keyboard shortcut
**Implemented:**
- Created src/recorder.py with AudioRecorder class for audio recording
- Created src/main.py as application entry point with global hotkey listener
- Created src/__init__.py to make src a proper Python package
- Implemented toggle recording behavior (press to start, press again to stop)
- Audio saved as WAV files in /tmp/ directory with timestamp filenames
- Used threading to avoid blocking keyboard listener during recording
- Configured 16kHz sample rate, mono channel for Whisper API compatibility
- Implemented 240-second maximum duration with automatic stop
- Added numpy dependency to requirements.txt

**Files changed:**
- src/recorder.py (created)
- src/main.py (created)
- src/__init__.py (created)
- requirements.txt (updated - added numpy)
- README.md (updated - added portaudio19-dev system dependency)

**Learnings:**
- sounddevice library requires system dependency: portaudio19-dev (must be installed via apt-get)
- pynput.keyboard.GlobalHotKeys is the correct class for cross-platform global hotkeys
- Audio data from sounddevice comes as float32 numpy arrays, must convert to int16 for WAV
- Threading is essential: recording runs in separate thread while keyboard listener remains responsive
- WAV files require specific format: setnchannels, setsampwidth(2 for 16-bit), setframerate
- /tmp/ directory is appropriate for temporary audio files (will be cleaned up by transcriber later)
- System dependency installation requires sudo, must be documented in README
- Audio conversion: multiply float32 by 32767 and cast to int16 for proper WAV encoding

---

## US-003 - Transcribe audio using OpenAI Whisper API
**Implemented:**
- Created src/transcriber.py with WhisperTranscriber class
- Integrated OpenAI Whisper API using the openai Python SDK (v2.15.0)
- Implemented config file reading from ~/.config/voice-ctrl/config.json with JSON parsing
- Configured API timeout to 30 seconds using OpenAI client timeout parameter
- Implemented comprehensive error handling with specific exception types
- Added automatic cleanup of temporary audio files using try/finally blocks
- Set up error logging to ~/.config/voice-ctrl/voice-ctrl.log with formatted timestamps
- Auto-create config directory (~/.config/voice-ctrl) if it doesn't exist using Path.mkdir()

**Files changed:**
- src/transcriber.py (created)

**Learnings:**
- OpenAI SDK v2.x uses client.audio.transcriptions.create() method (not Audio.transcribe())
- Must import specific exception classes: APIError, APIConnectionError, APITimeoutError, AuthenticationError, RateLimitError
- OpenAI client initialization: OpenAI(api_key=key, timeout=30.0) - timeout is a float in seconds
- Config file structure: Simple JSON with "openai_api_key" field
- File cleanup must be in finally block to ensure execution even when errors occur
- Python logging module needs basicConfig with filename, level, format, and datefmt parameters
- Path.mkdir(parents=True, exist_ok=True) creates all parent directories without errors if already exists
- API returns transcript object with .text attribute containing the transcribed string
- Whisper API accepts language parameter ("en" for English) though it can auto-detect
- Error logging format: [YYYY-MM-DD HH:MM:SS] LEVEL: message using %(asctime)s in format string
- Must open audio file in binary mode ('rb') when sending to API
- Path.unlink() deletes files, Path.exists() checks existence before deletion
- All errors should be caught, logged, and return None for graceful degradation

---

## US-004 - Insert transcribed text automatically
**Implemented:**
- Created src/paster.py with TextPaster class for clipboard-based text insertion
- Integrated TextPaster into main.py workflow (record → transcribe → paste)
- Implemented clipboard save and restore functionality with restore_clipboard parameter
- Added 100ms delay between clipboard copy and Ctrl+V to ensure clipboard readiness
- Comprehensive error handling for clipboard operations (empty text, None values, clipboard errors)
- Text pasting works via pyperclip + pynput keyboard simulation (Ctrl+V)

**Files changed:**
- src/paster.py (created)
- src/main.py (updated - added transcriber and paster integration)
- README.md (updated - added xclip system dependency)

**Learnings:**
- pyperclip requires system clipboard tool on Linux: xclip (X11), xsel, or wl-clipboard (Wayland)
- Must install xclip via apt-get: sudo apt-get install xclip
- pynput.keyboard.Controller simulates keystrokes at OS level, works across all applications
- Ctrl+V simulation: use with keyboard.pressed(Key.ctrl) context manager, then press/release 'v'
- Clipboard restore pattern: save with pyperclip.paste(), restore with pyperclip.copy() after delay
- 100ms delay (time.sleep(0.1)) between clipboard operations ensures reliability
- Edge cases handled: empty string, None, very long text all return appropriate success/failure status
- Paste returns boolean: True for success, False for failures (empty text, exceptions)
- Additional 100ms delay before restoring clipboard ensures paste operation completes
- Text truncation in logs ([:100]...) keeps console output readable for long transcriptions

---

## US-005 - Show system tray icon
**Implemented:**
- Created src/tray_icon.py with TrayIcon class for system tray management
- Implemented two icon states: idle (gray microphone) and recording (red microphone)
- Generated icons programmatically using PIL ImageDraw with simple microphone shapes
- Integrated tray icon into main.py with automatic state updates
- Icon runs in separate daemon thread to avoid blocking the main application
- Proper cleanup on application exit (stop icon when Ctrl+C pressed)
- Tooltip shows "Voice Control" on hover

**Files changed:**
- src/tray_icon.py (created)
- src/main.py (updated - added tray icon integration, fixed imports to use relative imports)

**Learnings:**
- pystray requires PIL (Pillow) for icon image creation
- Icon images created with Image.new('RGBA', (64, 64), (0, 0, 0, 0)) for transparent background
- PIL ImageDraw provides shapes: ellipse, rectangle, line, arc for drawing microphone icon
- pystray.Icon runs in blocking mode, must use threading.Thread(target=icon.run, daemon=True)
- Daemon thread ensures icon thread exits when main program exits
- Icon state changes via icon.icon = new_image_object (updates in real-time)
- main.py imports must be relative (.recorder, .transcriber, etc.) for proper module execution
- tray_icon.set_recording_state() called after recorder.toggle_recording() to sync icon state
- GNOME Shell on Ubuntu supports system tray icons (may need TopIcons extension on some systems)
- Test script confirmed: icon creation, start, state changes (idle↔recording), and stop all work correctly

---

## US-006 - Handle errors with notifications
**Implemented:**
- Created src/notifier.py with Notifier class for desktop notifications
- Integrated plyer library for cross-platform notifications (notify() function)
- Added specific notification methods for each error type:
  - notify_no_audio() - when no audio data recorded
  - notify_api_failure() - general API failures with optional details
  - notify_network_timeout() - 30-second timeout errors
  - notify_invalid_api_key() - authentication errors
  - notify_transcription_error() - general transcription errors
- Integrated notifier into transcriber.py to replace console error messages
- Integrated notifier into recorder.py to notify when no audio detected
- All errors logged to ~/.config/voice-ctrl/voice-ctrl.log with timestamp
- Notification timeout: 5 seconds for all error notifications
- Application continues running after non-fatal errors (returns None, doesn't crash)

**Files changed:**
- src/notifier.py (created)
- src/transcriber.py (updated - added notifier integration)
- src/recorder.py (updated - added notifier for no audio detection)
- test_notifier.py (created - test script)

**Learnings:**
- plyer.notification.notify() takes title, message, and timeout parameters
- plyer requires python3-dbus for best desktop integration on Linux, but has fallback
- Notifications work without sudo/special permissions on Ubuntu GNOME
- logging.basicConfig with force=True needed to override any existing logging config
- Notifier creates ~/.config/voice-ctrl/ directory automatically via Path.mkdir(parents=True, exist_ok=True)
- Each error type should have user-friendly messages (not technical details)
- Desktop notifications appear in system notification area for 5 seconds
- Log format: [YYYY-MM-DD HH:MM:SS] ERROR: Type: message
- notifier.notify_error() combines both desktop notification and file logging in one call
- Application continues running after errors since we return None instead of raising exceptions
- Test script confirms: all 5 error types show notifications and log correctly
- plyer fallback works even without dbus (uses notify-send command on Linux)

---

## US-007 - Use Shift+Insert for pasting instead of Ctrl+V
**Implemented:**
- Changed keyboard simulation from Ctrl+V to Shift+Insert in src/paster.py
- Modified TextPaster.paste_text() method to use Key.shift + Key.insert combination
- Updated all documentation strings and comments to reflect Shift+Insert usage
- Verified keystroke simulation works correctly with test script

**Files changed:**
- src/paster.py (updated - changed Ctrl+V to Shift+Insert in lines 9, 16, 54-58)

**Learnings:**
- Shift+Insert is the standard paste shortcut in Linux terminals and has better compatibility
- pynput Key class includes Key.insert constant for the Insert key
- Keyboard simulation pattern remains same: with keyboard.pressed(Key.shift): press/release Key.insert
- Shift+Insert works universally across terminal apps, terminal editors (vim, nano, emacs), and GUI apps
- Ctrl+V can be intercepted by terminals (e.g., vim uses it for visual block mode)
- Both shortcuts work in GUI apps, but Shift+Insert has superior terminal/CLI compatibility
- Test verified successful keystroke simulation output: "Simulated Shift+Insert keystroke"

---

## US-008 - Load settings from config file
**Implemented:**
- Created src/config.py with Config class for centralized settings management
- Implemented automatic default config creation at ~/.config/voice-ctrl/config.json on first run
- Added three configuration settings: api_key, max_duration_seconds, audio_feedback_enabled
- Implemented comprehensive config validation with type checking (string, number, boolean)
- Added error notifications for invalid config (JSON errors, type mismatches, missing file)
- Updated main.py to load Config and pass settings to components
- Refactored transcriber.py to use Config class instead of direct JSON reading
- Added backward compatibility for old 'openai_api_key' field (maps to 'api_key')
- Documented config file format and all options in README.md
- Tested all error scenarios: invalid JSON, invalid types, missing file

**Files changed:**
- src/config.py (created - 186 lines)
- src/main.py (updated - added Config import and initialization)
- src/transcriber.py (updated - removed _load_api_key method, now uses Config class)
- README.md (updated - added detailed config documentation with all options)

**Learnings:**
- Config management should be centralized in one module for consistency
- Always create default config on first run for better UX (user doesn't need to create manually)
- Config validation should check both structure and types (isinstance checks)
- Error notifications should be user-friendly, not technical (e.g., "Invalid config" not "JSONDecodeError")
- Use logging.basicConfig with force=True to override existing logging config across modules
- Backward compatibility is important: handle old field names (openai_api_key -> api_key)
- Settings should be applied at startup: pass config values to component constructors
- Config class methods should be semantic: get_api_key(), get_max_duration(), is_audio_feedback_enabled()
- Test invalid scenarios: malformed JSON, wrong types, missing files, negative numbers
- When refactoring, remove old code (deleted _load_api_key method) to avoid confusion
- Config should use .copy() on DEFAULT_CONFIG to prevent mutation
- Merge strategy: copy defaults first, then update with loaded values (ensures all keys exist)

---

## US-009 - Add audio feedback (beeps)
**Implemented:**
- Created src/audio_feedback.py with AudioFeedback class for playing beep sounds
- Implemented two distinct beeps: start (800 Hz, 0.1s) and stop (400 Hz, 0.15s)
- Integrated audio feedback into AudioRecorder class with audio_feedback_enabled parameter
- Updated main.py to pass audio_feedback_enabled config setting to recorder
- Beeps play asynchronously in daemon threads to avoid blocking recording
- Volume set to 0.3 (30%) for non-intrusive feedback
- Audio feedback can be toggled via set_enabled() method
- Respects audio_feedback_enabled config setting (defaults to True)

**Files changed:**
- src/audio_feedback.py (created - 87 lines)
- src/recorder.py (updated - added AudioFeedback import and integration)
- src/main.py (updated - pass audio_feedback_enabled from config)

**Learnings:**
- sounddevice library used for both recording and playback (no additional dependencies)
- Use numpy to generate sine wave beeps: np.sin(frequency * 2 * np.pi * t)
- Apply fade in/out envelope to prevent audio clicks at start/end of beep
- Fade duration: 10ms (0.01s) is sufficient to eliminate clicks
- Different frequencies convey different meanings: high (800 Hz) = start, low (400 Hz) = stop
- sd.play() is non-blocking by default - perfect for beeps
- Play beeps in daemon threads to ensure they don't prevent app shutdown
- Volume level 0.3 (30%) is loud enough to hear but not jarring
- Fail silently on audio playback errors (beeps are non-critical feature)
- Start beep plays BEFORE recording thread starts for immediate feedback
- Stop beep plays AFTER recording thread finishes to ensure audio doesn't interfere with recording
- AudioFeedback class is reusable and easily testable in isolation
- Integration test verified beeps play correctly and respect enabled/disabled state

---

## US-010 - Make keyboard shortcut configurable
**Implemented:**
- Added keyboard_shortcut setting to DEFAULT_CONFIG in config.py with default "Ctrl+Shift+Space"
- Implemented parse_keyboard_shortcut() function in main.py to parse user-friendly shortcut strings
- Supports common modifiers (Ctrl, Alt, Shift, Cmd) and special keys (Space, F1-F12, Insert, etc.)
- Parser converts user format ("Ctrl+Shift+Space") to pynput format ("<ctrl>+<shift>+<space>")
- Added comprehensive validation with helpful error messages showing valid format examples
- Shows desktop notification and exits gracefully if shortcut format is invalid
- Catches registration errors from pynput (e.g., invalid key combinations) with error notification
- Updated README with keyboard_shortcut documentation and usage notes

**Files changed:**
- src/config.py (updated - added keyboard_shortcut to DEFAULT_CONFIG, validation, and getter method)
- src/main.py (updated - added parse_keyboard_shortcut() function and error handling in main())
- README.md (updated - documented keyboard_shortcut setting with examples and restart requirement)

**Learnings:**
- pynput GlobalHotKeys requires format like "<ctrl>+<shift>+<space>" with angle brackets for special keys
- Parser must handle case-insensitive input ("Ctrl" vs "ctrl") and whitespace around + separator
- Single-character keys (a-z, 0-9) don't need angle brackets in pynput format
- Invalid shortcuts should fail early at startup with clear error messages, not silently
- Error messages should provide concrete examples of valid formats for better UX
- Shortcut validation has two stages: format parsing (our code) and registration (pynput library)
- Must catch exceptions from pynput.keyboard.GlobalHotKeys during registration (e.g., invalid combinations)
- Desktop notifications for config errors help users who run the app from autostart/systemd
- Config changes require app restart since pynput doesn't support dynamic hotkey re-registration
- Documenting the restart requirement is important for user expectations
- Parser supports function keys F1-F12 by generating key_map entries programmatically
- Using sys.exit(1) after configuration errors prevents app from running in broken state
- Map-based parsing approach is extensible for adding more special keys in future

---
## US-011 - Add settings window from tray icon
**Implemented:**
- Created src/settings_window.py with SettingsWindow class for GUI configuration
- Added show_about_dialog() function for About dialog
- Settings window displays all configurable options with proper UI controls:
  - Text entry for API key (masked with show="*")
  - Text entry for max recording duration (validated as positive integer)
  - Checkbox for audio feedback enabled/disabled
  - Text entry for keyboard shortcut string
- Implemented immediate save to config.json when user clicks Save button
- Added "Test Recording" button with instructions dialog
- Added menu to tray icon with three options: Settings, About, Quit
- Updated TrayIcon class to accept callback functions for menu items
- Menu handlers run in separate threads to avoid blocking tray icon
- Integrated settings window and about dialog into main.py
- Added on_quit callback to gracefully exit application
- Updated README.md with usage documentation for tray menu and settings window

**Files changed:**
- src/settings_window.py (created - 257 lines)
- src/tray_icon.py (updated - added menu support with callbacks)
- src/main.py (updated - added settings window and menu callback integration)
- README.md (updated - documented tray menu and settings window usage)

**Learnings:**
- tkinter is Python's standard GUI library but requires system package python3-tk on Ubuntu
- tkinter must be installed via apt-get: sudo apt-get install python3-tk (not in requirements.txt)
- pystray.Menu accepts pystray.MenuItem objects (imported as Item for brevity)
- Menu item callbacks receive (icon, item) parameters even if not used
- Menu callbacks should run in separate threads (threading.Thread) to avoid blocking tray icon
- Settings window should check if already open (self.window is not None) to avoid multiple instances
- window.lift() and window.focus_force() bring existing window to front
- Use ttk (themed tkinter) widgets for modern appearance: ttk.Label, ttk.Entry, ttk.Button, ttk.Checkbutton
- Entry widget show="*" parameter masks sensitive input like API keys
- BooleanVar is tkinter's way to bind checkbox state to a variable
- Config validation should happen before saving: check positive integers, valid types
- Use window.protocol("WM_DELETE_WINDOW", callback) to handle window close button
- window.mainloop() is blocking, so settings window runs in its own thread
- Test Recording button shows messagebox with instructions, then triggers recorder.toggle_recording()
- About dialog is simpler: separate Tk window with read-only information and Close button
- Geometry string format: "WIDTHxHEIGHT" e.g., "500x400" for window size
- window.resizable(False, False) prevents user from resizing the window
- Grid layout with padding: frame.grid(row=X, column=Y, sticky=tk.W, pady=5, padx=(10, 0))
- messagebox.showinfo(), messagebox.showerror(), messagebox.showwarning() for dialogs
- Config file updates should use json.load() then json.dump() to preserve formatting
- Settings window needs reference to Config object to read current values and save changes
- Optional recorder parameter allows Test Recording feature (graceful degradation if None)
- on_quit callback should check if recording active before exiting to clean up properly
- Document system dependencies clearly in README for better user experience
- GUI provides better UX than editing JSON manually, especially for non-technical users

---

## US-012 - API key setup wizard
**Implemented:**
- Created src/setup_wizard.py with SetupWizard class for first-time configuration
- Implemented validate_api_key() function that tests API key with OpenAI API
- Added should_show_setup_wizard() helper to detect when wizard should appear
- Wizard shows on first launch when API key is missing or empty
- GUI with tkinter displays setup dialog requesting OpenAI API key
- "Get API Key" button opens https://platform.openai.com/api-keys in browser
- API key validation makes test request to OpenAI (models.list()) to verify authentication
- Show/hide checkbox for API key visibility (default: masked with show="*")
- "Validate & Save" button validates key and saves to config file
- "Skip (Configure Later)" button allows users to postpone setup
- Integrated wizard into main.py startup flow before other initialization
- Config reloaded after successful setup to pick up new API key

**Files changed:**
- src/setup_wizard.py (created - 309 lines)
- src/main.py (updated - added SetupWizard import and startup integration)

**Learnings:**
- First-time setup wizard improves onboarding UX significantly for new users
- API key validation should use lightweight endpoint (models.list()) not full transcription test
- webbrowser.open() provides cross-platform way to open URLs in default browser
- Modal window behavior using window.grab_set() prevents interaction with other windows
- Show/hide password toggle improves UX for long API keys (easier to verify when pasting)
- Validation should happen before save: test API key authenticity before writing to config
- Handle multiple error types from OpenAI: AuthenticationError, APIConnectionError, APIError
- Status label with color coding (gray/blue/green/red) provides clear visual feedback during validation
- Button state management: disable during validation, re-enable on error (prevents double-click issues)
- Skip option important for flexibility: users may want to get key later or configure manually
- Wizard returns API key on success, None on skip - allows caller to know outcome
- Config reload after setup ensures main app uses newly saved API key
- Entry widget focus() on startup improves UX (user can immediately start typing)
- Bind Enter key to submit action (wizard.show()) for keyboard-friendly workflow
- Protocol handler for WM_DELETE_WINDOW ensures proper cleanup when window closed
- Test validation with invalid key first to confirm error handling works correctly
- client.models.list() is faster and cheaper than transcription for validation
- pathlib.Path.parent.mkdir(parents=True, exist_ok=True) ensures config directory exists before save
- Merge new API key with existing config to preserve other settings (don't overwrite everything)
- should_show_setup_wizard() centralizes detection logic: shows when api_key is empty or whitespace

---

## US-013 - Fix tray icon tooltip not showing on hover
**Implemented:**
- Updated pystray.Icon initialization to use explicit keyword arguments
- Changed from positional args to keyword args: name=, icon=, title=, menu=
- Added comment clarifying that title parameter sets the tooltip text
- Verified tooltip "Voice Control" is properly set via pystray.Icon.title attribute

**Files changed:**
- src/tray_icon.py (updated - line 135-140: use keyword arguments for pystray.Icon)

**Learnings:**
- pystray.Icon accepts tooltip via the 'title' parameter (3rd positional or keyword arg)
- Using keyword arguments (name=, icon=, title=, menu=) is more explicit and maintainable than positional args
- The pystray library correctly sets the tooltip regardless of positional vs keyword argument style
- Tooltip display in GNOME Shell may vary by system configuration and extensions installed
- Explicit keyword arguments make code intent clearer and prevent parameter order mistakes
- The title attribute can be verified programmatically via icon.title after creation
- Testing showed tooltip is set correctly in code; any display issues are environmental (GNOME Shell/AppIndicator behavior)
- Adding menu to tray icon does not break tooltip functionality when properly configured

---

## US-014 - Auto-initialize all config parameters on first run
**Implemented:**
- Added config migration logic in Config._load_config() to detect missing parameters
- Migration writes complete merged config back to disk when parameters are missing
- Ensures all 4 default parameters (api_key, max_duration_seconds, audio_feedback_enabled, keyboard_shortcut) exist in config file
- Works for both new installs (fresh config creation) and existing configs (migration)
- Maintains backward compatibility with old openai_api_key field

**Files changed:**
- src/config.py (updated - added migration logic lines 91-108)

**Learnings:**
- Config migration requires TWO steps: merge in memory AND write back to disk
- Previous implementation only merged in memory - users still had incomplete config files on disk
- Check needs_migration by iterating through DEFAULT_CONFIG keys and checking if they exist in loaded config
- Migration should print user-friendly messages to explain what's happening
- Error handling during migration write should be non-fatal (log warning but continue with merged config in memory)
- Test all scenarios: fresh config, old config with only api_key, backward compatibility with openai_api_key
- json.dump with indent=2 creates readable config files that users can manually edit if needed
- Migration is idempotent - running multiple times on a complete config doesn't cause issues
- The issue was setup_wizard created partial configs in some cases, but even when it created full configs, users who had old configs from before all parameters existed needed migration
- Config file on disk must match what's loaded in memory to avoid user confusion when editing config manually

---

## US-015 - Fix auto-stop to transcribe recording before exiting
**Implemented:**
- Added callback mechanism (on_auto_stop_callback) to AudioRecorder class
- Implemented _handle_auto_stop() method that performs same actions as manual stop
- Auto-stop now plays stop beep, saves audio file, and triggers transcription workflow
- Added notification to inform user when auto-stop occurs
- Refactored main.py to extract process_audio_file() function for code reuse
- Set up auto-stop callback in main.py to trigger transcription and paste
- Tray icon state properly updates after auto-stop processing completes

**Files changed:**
- src/recorder.py (updated - added callback mechanism and auto-stop handler)
- src/main.py (updated - refactored audio processing and added auto-stop callback setup)

**Learnings:**
- Auto-stop logic must trigger the same workflow as manual stop to ensure audio is processed
- Simply setting is_recording=False in the recording thread is insufficient - need explicit handling
- Callback pattern is ideal for decoupling recorder from transcription/paste logic
- Threading considerations: _handle_auto_stop runs in separate daemon thread to avoid blocking
- Must wait for recording_thread to join before processing audio (ensures all audio data captured)
- Desktop notification informs user that auto-stop occurred and transcription is happening
- Code reuse: Extract common logic (process_audio_file) when manual and auto-stop share behavior
- Tray icon state must be updated after processing completes, not just when recording stops
- Test with short max_duration (5 seconds) makes it easy to verify auto-stop functionality quickly
- The bug occurred because original auto-stop only set flag but didn't trigger save/transcribe pipeline
- Recording thread cannot directly call stop_recording() due to deadlock (would join itself)
- Solution: Spawn new thread for _handle_auto_stop to handle cleanup and callbacks independently

---

## US-016 - Fix tray icon right-click menu not appearing
**Implemented:**
- Changed menu creation pattern from static pystray.Menu to callable function
- Modified _create_menu() to return menu_builder function that dynamically creates items
- Menu items are now built on-demand when icon is clicked (left or right)
- Created test script (test_menu_fix.py) for manual verification
- Verified menu creation programmatically: 3 items (Settings, About, Quit)

**Files changed:**
- src/tray_icon.py (updated - changed _create_menu to return callable instead of Menu object)
- test_menu_fix.py (created - manual test script)

**Learnings:**
- pystray on Linux with AppIndicator requires menu to be a callable, not a static Menu object
- Callable pattern: function that accepts icon parameter and returns list of MenuItem objects
- This pattern ensures menu works on both GNOME Shell and other Linux desktop environments
- Static pystray.Menu(...) might not trigger properly on some systems with AppIndicator
- Callable menus are rebuilt dynamically on each click, ensuring they always work
- Menu appears on both left-click and right-click when using AppIndicator backend
- Testing showed menu_builder(None) correctly returns 3 items with proper text attributes
- The icon parameter passed to menu_builder allows for dynamic menu content based on state
- This is the recommended pattern in pystray for Linux desktop integration

---

## US-017 - Fix setup wizard save button visibility
**Implemented:**
- Increased setup wizard window height from 400px to 550px
- Ensured all UI elements are visible including buttons at bottom
- Window now has 35px extra vertical space for comfortable viewing
- All elements (title, description, instructions, input, checkbox, status, buttons) are fully visible

**Files changed:**
- src/setup_wizard.py (updated - window geometry from 550x400 to 550x550)

**Learnings:**
- tkinter window geometry includes title bar and window decorations in calculation
- Content layout with multiple rows and padding can easily exceed initial window size estimates
- Main frame with 30px padding uses 60px total vertical space (top + bottom)
- Each UI element with pady padding adds to total height: title (10px), desc (20px), instructions (20px), button (20px), entry (10px), checkbox (10px), status (10px), button frame (10px)
- Actual content height for this layout: 515px total (485px main frame + 30px padding each side)
- Testing window geometry programmatically using winfo_reqheight() and winfo_y() provides accurate measurements
- Always add buffer space (35-50px) beyond calculated minimum to avoid edge cases with font rendering differences
- Button visibility issues are common when window height is set too small for stacked vertical layouts
- Users forced to use Enter key when buttons are invisible due to window size
- Window height of 550px provides comfortable spacing and ensures all elements are accessible

---

## US-018 - Fix xclip timeout warnings during clipboard operations
**Implemented:**
- Increased xclip timeout from 1.0 seconds to 3.0 seconds for CLIPBOARD selection
- Increased xclip timeout from 1.0 seconds to 3.0 seconds for PRIMARY selection
- Fallback to pyperclip already existed in exception handlers and continues to work
- Prevents "Command timed out after 1.0 seconds" warnings during clipboard operations
- Clipboard operations now have reasonable time to complete

**Files changed:**
- src/paster.py (updated - lines 55 and 72: timeout=1.0 changed to timeout=3.0)

**Learnings:**
- xclip can take longer than 1 second to complete on some systems depending on X11 load
- 1.0 second timeout was too aggressive and caused false positive warnings
- 3.0 seconds provides comfortable buffer while still being reasonable for user experience
- subprocess.run() timeout parameter accepts float values in seconds
- Exception handling already catches subprocess.TimeoutExpired and falls back to pyperclip
- Both CLIPBOARD and PRIMARY selections need same timeout to ensure consistency
- Timeout warnings were confusing to users even when paste functionality worked correctly
- The warning appeared as subprocess.TimeoutExpired exception in the generic Exception handler
- Increasing timeout reduces unnecessary fallback triggers and improves reliability
- pyperclip fallback remains important for edge cases and systems without xclip

---

## US-019 - Fix tray icon menu not appearing with PyGObject integration
**Implemented:**
- Identified root cause: pystray was using X11 backend instead of AppIndicator
- X11 backend has limited menu support on GNOME Shell (menu builder called but not displayed)
- Installed required system packages: python3-gi, python3-gi-cairo, gir1.2-gtk-3.0
- Recreated virtual environment with --system-site-packages flag to access PyGObject
- Modified tray_icon.py to explicitly import and use AppIndicator backend
- Added backend detection with fallback to X11 if AppIndicator unavailable
- Updated README.md with complete system dependency list and installation order
- Menu now works with dynamic callable pattern using Menu(menu_builder)
- Cleaned up debug print statements after successful testing

**Files changed:**
- src/tray_icon.py (updated - explicit AppIndicator backend import and usage)
- README.md (updated - added PyGObject dependencies and --system-site-packages flag)

**Learnings:**
- pystray has two backends on Linux: AppIndicator (preferred) and X11 (fallback)
- AppIndicator backend requires PyGObject (gi module) which is a system package, not pip-installable
- System packages python3-gi, python3-gi-cairo, gir1.2-gtk-3.0 required for AppIndicator
- Virtual environment must use --system-site-packages flag to access system-installed PyGObject
- AppIndicator uses AyatanaAppIndicator3 on modern Ubuntu (not AppIndicator3)
- X11 backend shows icon but menus don't appear on GNOME Shell even with correct callable pattern
- AppIndicator backend provides better GNOME Shell integration and renders icon differently
- Dynamic menu pattern: Menu(callable) where callable returns list of MenuItem objects
- Explicit backend import: from pystray import _appindicator as pystray_backend
- System dependencies must be installed BEFORE creating virtual environment
- Installation order matters: system packages → venv creation → pip install
- PyGObject cannot be pip-installed reliably, must use system package manager
- AppIndicator menus respond to left-click on GNOME Shell (not just right-click)
- Backend selection can be forced by importing specific backend module directly
- Better to explicitly select backend than rely on pystray's auto-detection

---

## US-019 - Transcription history log
**Implemented:**
- Created src/history.py with HistoryManager class for transcription storage
- History stored in ~/.config/voice-ctrl/history.json with last 30 transcriptions
- Each entry includes: timestamp (ISO format YYYY-MM-DD HH:MM:SS), text, duration_seconds
- Automatic trimming to 30 most recent entries when adding new transcription
- Created src/history_window.py with HistoryWindow GUI for viewing history
- Scrollable list showing recent transcriptions with timestamp, duration, and full text
- "Copy to Clipboard" button for each entry using pyperclip
- "Clear History" button with confirmation dialog
- Added "View History" menu item to tray icon (appears first in menu list)
- Integrated history logging into main.py workflow after successful transcription
- Duration tracking from recorder.start_time for accurate recording length

**Files changed:**
- src/history.py (created - 160 lines)
- src/history_window.py (created - 265 lines)
- src/main.py (updated - added HistoryManager import, history logging in process_audio_file)
- src/tray_icon.py (updated - added on_view_history callback and menu item)
- test_history.py (created - test script)

**Learnings:**
- History management should be a separate module for clean separation of concerns
- JSON format for history file makes it human-readable and easy to inspect/debug
- List with newest entries first (insert at index 0) provides natural ordering for display
- Trimming to max entries during add prevents file from growing unboundedly
- Validation of entry structure on load handles corrupted/invalid history files gracefully
- Duration must be captured from recorder.start_time before toggle_recording completes
- process_audio_file modified to accept optional duration_seconds parameter
- Both manual stop (on_hotkey) and auto-stop (on_auto_stop) need duration tracking
- tkinter Text widget with state="disabled" provides read-only text display with proper formatting
- Canvas + Scrollbar pattern for scrollable frame allows unlimited history entries
- Clear History should show confirmation dialog (askyesno) to prevent accidental data loss
- Window reopen after clear shows empty state message for better UX
- History window can be reopened multiple times - use lift() and focus_force() if already open
- Menu item order matters: View History first, then Settings, About, Quit for logical grouping
- pyperclip integration for copy buttons reuses existing clipboard dependency
- Test script validates: entry count, field structure, order (newest first), trimming behavior
- MAX_ENTRIES constant (30) makes limit configurable and self-documenting
- ISO format timestamps (YYYY-MM-DD HH:MM:SS) are both human-readable and sortable
- HistoryManager logger uses standard logging module for consistency with other components
- Empty state in UI ("No transcription history yet") improves first-run experience
- Threading pattern for menu callbacks (daemon=True) consistent with other menu items
- History file location in ~/.config/voice-ctrl/ follows Linux config conventions

---

## US-020 - Create .deb package for easy installation
**Implemented:**
- Created complete Debian package structure in packaging/ directory
- DEBIAN/control file with package metadata, version 1.0.0, and all system dependencies
- DEBIAN/postinst script that creates virtual environment with --system-site-packages flag
- DEBIAN/prerm script for clean uninstallation (removes autostart file)
- Launcher script at /usr/bin/voice-ctrl that activates venv and runs application
- Desktop file at /usr/share/applications/voice-ctrl.desktop for application menu
- Application icon (48x48 PNG) at /usr/share/pixmaps/voice-ctrl.png
- Build script (build_deb.sh) that packages everything into voice-ctrl.deb
- Package installs application to /opt/voice-ctrl

**Files changed:**
- packaging/voice-ctrl/DEBIAN/control (created - package metadata)
- packaging/voice-ctrl/DEBIAN/postinst (created - venv setup script)
- packaging/voice-ctrl/DEBIAN/prerm (created - cleanup script)
- packaging/voice-ctrl/usr/bin/voice-ctrl (created - launcher script)
- packaging/voice-ctrl/usr/share/applications/voice-ctrl.desktop (created)
- packaging/voice-ctrl/usr/share/pixmaps/voice-ctrl.png (created - icon)
- build_deb.sh (created - build automation)
- packaging/README.md (created - documentation)
- PACKAGE_TESTING.md (created - testing guide)
- .gitignore (updated - exclude *.deb and packaging/voice-ctrl/opt/)

**Learnings:**
- Debian package structure requires DEBIAN/ directory with control, postinst, prerm scripts
- control file format: Package, Version, Section, Priority, Architecture, Depends, Maintainer, Description
- Dependencies list system packages (python3-gi, etc.) not pip packages
- Depends field uses comma-separated list with version constraints: python3 (>= 3.8)
- postinst script runs after package extraction, perfect for venv setup
- Virtual environment MUST use --system-site-packages to access PyGObject (python3-gi)
- PyGObject cannot be pip-installed, only available as system package
- prerm script runs before package removal, good for cleanup
- Scripts in DEBIAN/ must be executable (chmod 755)
- Application files typically go in /opt/ for third-party software
- Launcher script goes in /usr/bin/ and must be executable
- Desktop files go in /usr/share/applications/ for app menu integration
- Desktop file format: [Desktop Entry] with Name, Comment, Exec, Icon, Terminal, Type, Categories
- Icons go in /usr/share/pixmaps/ (or /usr/share/icons/ for multiple sizes)
- Icon in .desktop file references name without path or extension (Icon=voice-ctrl)
- dpkg-deb --build creates the .deb package from directory structure
- Package filename becomes directory-name.deb (packaging/voice-ctrl → voice-ctrl.deb)
- Must remove __pycache__ directories before packaging (bloat + unnecessary)
- Build script should clean previous build artifacts before creating package
- .gitignore should exclude *.deb files and build artifacts (packaging/voice-ctrl/opt/)
- Package size: ~20KB for source files (before venv creation in postinst)
- dpkg-deb --info shows package metadata, --contents shows file listing
- Installation: sudo dpkg -i package.deb, then sudo apt-get install -f for dependencies
- Uninstall: sudo apt remove package-name (preserves user config)
- Purge: sudo apt purge package-name (removes config too)
- User config in ~/.config/ should NOT be removed during package removal
- postinst activates venv and runs pip install to set up Python dependencies
- Launcher script cd to /opt/voice-ctrl, activates venv, runs python3 -m src.main
- Desktop file Categories should match freedesktop.org spec (Utility;Accessibility;)
- StartupNotify=false prevents "loading" cursor since app is background service
- Terminal=false prevents terminal window from opening
- PIL can create simple icons programmatically (no need for external icon files)
- 48x48 is standard size for application icons in system menus
- Package provides clean, user-friendly installation experience vs manual setup

---

## US-021 - Add desktop autostart support
**Implemented:**
- Added autostart_enabled parameter to config.py DEFAULT_CONFIG (defaults to false)
- Added is_autostart_enabled() getter method to Config class
- Added autostart_enabled validation in _validate_config() (checks boolean type)
- Added "Start at Login" checkbox to Settings window
- Implemented _create_autostart_file() method to create ~/.config/autostart/voice-ctrl.desktop
- Implemented _remove_autostart_file() method to remove autostart file
- Implemented _get_autostart_path() to get ~/.config/autostart/voice-ctrl.desktop path
- Implemented _get_executable_path() to detect correct executable (installed vs source)
- Autostart desktop file includes proper fields: Hidden=false, X-GNOME-Autostart-enabled=true
- Settings window automatically creates/removes autostart file when checkbox toggled
- Window height increased from 420px to 470px to accommodate new checkbox

**Files changed:**
- src/config.py (updated - added autostart_enabled to DEFAULT_CONFIG, validation, and getter)
- src/settings_window.py (updated - added checkbox, autostart file management methods, imports)

**Learnings:**
- Autostart files on Linux go in ~/.config/autostart/ directory with .desktop extension
- Desktop Entry format requires: Type, Name, Comment, Exec, Icon, Terminal, Hidden, X-GNOME-Autostart-enabled
- Hidden=false is required for autostart (Hidden=true disables autostart)
- X-GNOME-Autostart-enabled=true ensures GNOME Shell recognizes autostart setting
- Terminal=false prevents terminal window from appearing on autostart
- Exec path must be absolute or use bash -c wrapper to cd to project directory first
- Executable path detection: check /usr/bin/voice-ctrl first (installed), fallback to source
- For source execution: use "bash -c 'cd /absolute/path && python3 -m src.main'" pattern
- Path(__file__).parent.parent gives project root from settings_window.py
- Config migration automatically adds autostart_enabled to existing configs
- Settings window save method compares old vs new autostart state to know when to create/remove file
- Create autostart directory with Path.mkdir(parents=True, exist_ok=True) before writing file
- Path.unlink() removes files, Path.exists() checks if file exists before removal
- Error handling should be non-fatal with warnings (autostart is convenience feature)
- Window height calculation: each row with pady=8 adds ~40px, account for all UI elements
- BooleanVar used for checkbox state binding in tkinter
- Config validation ensures autostart_enabled is boolean type (not string or int)
- Testing: create file, verify content, remove file, verify removal all work correctly
- Autostart works for both .deb installed version and running from source

---

